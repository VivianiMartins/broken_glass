<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
    </head>
    <body>
        <!-- //código do shader. Cada shader vai fazer multiplicação p/ cada vértice. Variavel global que tem q ser definida gl_Position -->
        <!--O primeiro script: Aqui estou passando as coordenadas do vértice - A Vertex shader which provides the clip space coordinates-->
        <!--O segundo script: Aqui estou provendo as cores - a fragment shader that provides the color-->
        <script type="vertex" id="vs">
            #version 300 es
            precision highp float;
            in vec4 position;
            in vec2 color;

            uniform mat4 mvpMatrix;
            out vec4 vColor;

            void main() {
                vColor = vec4(color, 0.0, 1.0);
                gl_Position = mvpMatrix*position;
            }
        </script>

        <script type="fragment" id="fs">
            #version 300 es
            precision highp float;
            in vec4 vColor;

            out vec4 fragColor;

            void main() {
                fragColor=vColor;
            }
        </script>

        <canvas id="webgl-canvas"></canvas>
        <script type="text/javascript" src="scripts/MV.js"></script>
        <script type="text/javascript" src="scripts/voronoi_diagrams.js"></script>
        <script>
            let canvas = document.getElementById("webgl-canvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            let aspect= canvas.width/canvas.height;
            console.log('canvas');
            console.log(aspect);
            console.log(canvas.width);
            console.log(canvas.height);

            //criando o contexto de renderização:
            let gl = canvas.getContext("webgl2");
            if (!gl) {
                console.error("WebGL 2 not available");
                document.body.innerHTML = "This example requires WebGL 2 which is unavailable on this system."
            }

            //cor do fundo
            gl.clearColor(0, 0, 0, 1);//preto
            gl.enable(gl.DEPTH_TEST);
            let vsSource = document.getElementById("vs").text.trim();
            let fsSource = document.getElementById("fs").text.trim();

            //Vertex - criando seu shader
            let vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vsSource);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(vertexShader));
            }
            //Fragment - criando seu shader
            let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fsSource);
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(fragmentShader));
            }

            //Linkando os shaders ao programa
            let program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
            }
            //Usar o programa - shadders
            gl.useProgram(program);

            //1. Define os arrays de vertices
            //Define os arrays de vertices usando a Lógica de Voronoi. Chamando as funções
            // para criar os pontos gerando numero total de pontos:
            let totalPoints = getRandomInt(3, 15);
            let vertexColors =[];
            let polygonVertices = [totalPoints];//poligonos
            let vertices = [totalPoints];
            let sites = setSites(totalPoints); //sites
            fillVoronoi (sites);

            //definindo apenas os vertices
            for (let i = 0; i < totalPoints; i++) {
                vertices[i] = [sites[i].x, sites[i].y];
            }

            // Definindo as cores para cada região de Voronoi com cores próximas de vidro e uma branca
            vertexColors.push(vec4(1.0,1.0,1.0,1.0));
            for (let i = 1; i < totalPoints; i++) {
                vertexColors.push(vec4(0.8,0.9,1.0,0.8));
            }
            
            //Exibindo informações dos pontos após a função fillVoronoi
            console.log('Total de pontos', totalPoints);
            console.log('Sites', sites);
            console.log('Vertex', vertices);
            console.log("Pontos de Voronoi:");
            for (let i = 0; i < totalPoints; i++) {
                let site = sites[i];
                console.log(`Ponto ${i + 1}: Coordenadas (${site.x}, ${site.y}), Semente: (${site.seed.x}, ${site.seed.y})`);
            }

            //inserir os vertices que serão desenhados
            for (let i = 0; i < totalPoints; i++) {
                //Agora sim vai desenhar - Obtenha os vértices da célula de Voronoi
                let cellVertices = getVoronoiCellVertices(i, vertices);
                // Adicione os vértices ao array polygonVertices
                polygonVertices = polygonVertices.concat(cellVertices);
            }
            let flattenedPolygonVertices = [];
            for (let i = 0; i < polygonVertices.length; i++) {
                flattenedPolygonVertices.push(polygonVertices[i]);
            }

            //3. Copiar para GPU
            //Vertices - attributes get their data from buffers, so we need to create a buffer
            let positionBuffer = gl.createBuffer();
            // First you bind a resource to a bind point. Then, all other functions refer to the resource through the bind point. So, let's bind the position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER,positionBuffer);
            //Now we can put data in that buffer by referencing it through the bind point - definidos acima
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(flattenedPolygonVertices), gl.STATIC_DRAW);
            //location of the attribute for the program - deve ser feito na inicialização e não na renderização
            let positionLoc = gl.getAttribLocation(program,"position");
            //Then we need to specify how to pull the data out
            gl.vertexAttribPointer(positionLoc,2,gl.FLOAT,false,0,0);
            //This tells WebGL we want to get data out of a buffer. If we don't turn on the attribute then the attribute will have a constant value.
            gl.enableVertexAttribArray(positionLoc);

            //Cores - Attributes get their data from buffers, so we need to create a buffer
            let colorBuffer = gl.createBuffer();
            // First you bind a resource to a bind point. Then, all other functions refer to the resource through the bind point. So, let's bind the position buffer.
            gl.bindBuffer(gl.ARRAY_BUFFER,colorBuffer);
            //Now we can put data in that buffer by referencing it through the bind point - definidos acima
            gl.bufferData(gl.ARRAY_BUFFER,flatten(vertexColors),gl.STATIC_DRAW);
            //location of the attribute for the program  - deve ser feito na inicialização e não na renderização
            let colorLoc = gl.getUniformLocation(program, "color");
            //Then we need to specify how to pull the data out
            gl.vertexAttribPointer(colorLoc,4,gl.FLOAT,false,0,0);
            //This tells WebGL we want to get data out of a buffer. If we don't turn on the attribute then the attribute will have a constant value.
            gl.enableVertexAttribArray(colorLoc);


            ////////////////
            // DRAW
            ////////////////
            //posição da câmera é 4, está apontando para o centro e em "pé" no eixo y
            let eye= vec3(0,0,4), target=vec3(0,0,0), up = vec3(0,1,0) ;
            let viewMatrix= lookAt(eye,target,up);
            //o que será visto, near =  tem que ser menor que a distância da câmera, que é 3, foi usado 1;
            // far = 4, vai pegar até o -1 de profundidade
            let projectionMatrix = perspective(45,aspect,1,4);
            //definir uma matriz, a ordem de multiplicação é: projection x view
            let mvp= mult(projectionMatrix,viewMatrix);

            let mvpMatrixLoc= gl.getUniformLocation(program,"mvpMatrix");
            gl.uniformMatrix4fv(mvpMatrixLoc,false,flatten(mvp));

            console.log('viewMatrix', viewMatrix);
            console.log('projectionMatrix', projectionMatrix);
            console.log('view projection', mvp);
            console.log('vpMatrixLoc', mvpMatrixLoc);
            console.log('Vertex shader compile status:', gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS));
            console.log('Vertex shader info log:', gl.getShaderInfoLog(vertexShader));
            console.log('Fragment shader compile status:', gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS));
            console.log('Fragment shader info log:', gl.getShaderInfoLog(fragmentShader));

            let render = function (){
                gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                gl.drawArrays(gl.LINE_LOOP, 0, flattenedPolygonVertices.length/2);
                requestAnimationFrame(render);
            }
            render ();
        </script>
    </body>

</html>
